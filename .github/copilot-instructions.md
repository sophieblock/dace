# Copilot Instructions for DaCe
- **Big Picture**: DaCe turns high-level code into Stateful DataFlow multiGraphs (SDFGs); the core IR lives in `dace/sdfg` with states in `dace/sdfg/state.py`, data descriptors in `dace/data.py`, and memlets in `dace/memlet.py`.
- **Frontend Pipeline**: User-facing decorators (`@dace.program`, `@dace.method`) are implemented in `dace/frontend/python/interface.py`, which build a `parser.DaceProgram` from `dace/frontend/python/parser.py` before lowering to SDFGs.
- **Transformations**: Programmatic optimizations derive from `dace.transformation.transformation.PatternTransformation`; register expansions or tuners via helpers in `dace/library.py` and `dace/optimization/`.
- **Library Nodes**: Reuse device-tuned building blocks from `dace/libraries/**`; when adding a node, decorate with `@dace.library.node`, provide `implementations`, and place custom expansions under the same module so `register_implementation` wires them automatically.
- **Code Generation**: `dace/codegen` lowers SDFGs to target code; `dace/codegen/compiled_sdfg.py` orchestrates compiling shared libraries into `.dacecache/<program>` with CMake toolchains gathered from `dace/codegen/*.cmake` and runtime headers in `dace/runtime/include`.
- **Backend Targets**: GPU/FPGA emitters live in `dace/codegen/targets/`; follow existing target modules for entry points, naming, and environment registration in `dace/library.py` when adding hardware support.
- **Config System**: Central configuration is exposed through `dace/config.py` and schema `dace/config_schema.yml`; prefer `Config.get/set` or `hooks.set_temporary` in tests instead of environment hacks.
- **Hooks and Instrumentation**: Use `dace/hooks.py` (`on_call`, `on_compiled_sdfg_call`) to inject profiling or debugging without modifying core code paths.
- **Caching Awareness**: Generated sources land in `.dacecache/<sdfg>/src`, CMake builds in `.dacecache/<sdfg>/build`; delete that folder to force recompilation when diagnosing codegen issues.
- **CLI Tools**: Entry points defined in `setup.py` invoke modules under `dace/cli/`; mirror their argument parsing and config usage for new command-line utilities.
- **External Assets**: Headers and kernels under `dace/external/**` and `dace/libraries/**/include` are packaged by `setup.py`; keep licensing files alongside additions and update `package_data`.
- **Runtime Contracts**: Generated code expects the runtime support in `dace/runtime/`; extend C++ helpers there rather than embedding large snippets in code generators.
- **Samples & Tutorials**: Reference `samples/` and `tutorials/` for idiomatic SDFG usage patterns; they double as regression baselines when changing frontend semantics.
- **Testing Workflow**: Install extras with `pip install -e ".[testing]"`, run focused suites via `python -m pytest tests/<area>`; `./test_all.sh` orchestrates mixed C++/CUDA/Python tests with timeout control.
- **Pytest Markers**: `pytest.ini` declares markers like `gpu`, `fpga`, `mpi`, `long`; gate hardware-specific tests with these markers and skip responsibly in CI.
- **Serialization Tests**: Many tests toggle `DACE_testing_serialization`; rely on context managers in `tests/serialization_utils.py` (if present) instead of manual env hacking.
- **Docs Pipeline**: Build docs from `doc/` using `pip install -e ".[docs]"` then `make -C doc html`; docstrings are Sphinx-formatted per `CONTRIBUTING.md`.
- **Style Guardrails**: Follow `CONTRIBUTING.md` (type hints required, no `import *`, imports at top, Google Python style); run `pre-commit run --all-files` before submitting.
- **Properties System**: Extend IR classes using `dace.properties.make_properties` and property descriptors in `dace/properties.py` to keep configuration serializable.
- **Symbolics**: Leverage `dace/symbolic.py` for SymPy-backed expressions; treat symbols as positive unless `Config('optimizer','symbolic_positive')` says otherwise.
- **Data Descriptors**: Allocate new array-like types by subclassing descriptors in `dace/data.py`, making sure to update serialization hooks in `dace/serialize.py`.
- **Viewer Integration**: Frontend tools expect compiled SDFGs to be discoverable; use helpers in `dace/sdfg/utils.py` like `load_precompiled_sdfg` to reuse generated binaries.
- **Versioning**: Bump `dace/version.py`, `setup.py`, and `dace.egg-info/PKG-INFO` together, and document changes if CI relies on specific extras.
- **Dependency Changes**: When adding Python dependencies, update both `setup.py` and `requirements.txt`, and document rationale in the PR per `CONTRIBUTING.md`.
- **Common Debug Flow**: Inspect generated C++ via `.dacecache/<prog>/src`, tweak config (`Config.set('compiler','build_type', value='Debug')`), and use `hooks.on_compiled_sdfg_call` for logging before editing generated files.
- **Reference Guides**: The high-level overview in `README.md` and deeper design notes under `doc/general/` and `doc/codegen/` explain why abstractions look the way they doâ€”consult them before reworking architecture.
